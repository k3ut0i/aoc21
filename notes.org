* TODO Day 01
  - Note taken on [2021-12-19 Sun 16:50] \\
    I am getting a repeat count for the second part of the answer.
    There is some problem with boundary condition. Fix this.
  I just need to iterate through the list once. So a simple linked list would suffice.
  - Since creating the list would give me the reverse of it, I need to count the decreasing depth.
    + Hmm, it would seem that ~std::list~ allows iterating from the back too(doubly linked list).
      I will just iterate from the back for simplicity.

* DONE Day 02
  In the previous problem, when trying to read numbers sequentially, I did ~filestream >> num~. I want to do this for a complicated data structure ~filestream >> data~. What should I define for this to work?
  <2021-12-19 Sun> Got it to work. There is a bug. If the eof does not occur directly after the data, i.e., there is an extra newline, [[file:src/day02.cc::std::list<struct command> read_commands(std::string filename) {][~read_commands~]], then the program crashes trying to parse this whitespace into a ~struct command~. Now how do I tell if all that is left in the stream is whitespace?
  <2021-12-20 Mon> Solved the whitespace before eof problem by just ~peek~ and ~get~ while the ~peek~ satisfies ~isspace~.

* DONE Day 03
  I have solved a similar problem before on Average of several DNA sequences. 
  I did not use any ~lambdas~. There are instances to use ~map~ on ~std::list~, but I seem to be just using ~for~ loops.
  <2021-12-20 Mon> Something is segfaulting in part2; probably some dereferencing a bitset.
  <2021-12-21 Tue> I was deleting nodes in a list while traversing. So when I deleted a node and then used it to get the next node, the result was a segfault.

* DONE Day 04
  Finished coding the logic. Cards are not being marked at all. Needs debugging.
  - The set of marked indices is not being updated. What am I missing?
    + figured it out. I should have passed ranged over state using ~auto &~. By just using ~auto~ I was not propagating changes back to state.
  - Similar to previous day, I seem to be struggling with deleting nodes of a list while traversing it.
  I would not have struggled this much if I just tried to simulate the whole process of find the last card in my head.
  
* DONE Day 05
  Finding the density of lines.
  - I am loving the ~operator>>~ to parse the incoming data. Feels quite like Haskell ~ReadS~ parsing.
  - Took a couple of tries to get the line stepping logic to get right.

* DONE Day 06
  I am having trouble using header files and libraries.
  - linker is complaining of unable to resolve the function reference. Is there a problem with function name or template instantiation?
    + I almost stumbled upon the answer. Since a templated function compiled into instantiated versions where it is required, we need to know it's uses before compiling the object file. Thus we can only use it if the definition is within the translation unit of it's use. We can do this if the function is defined within the header file. We cannot enumerate all instances of template function; thus every instantiation might be compiled again anyway. So this is not much of a disadvantage to the compilaiton process.
  For the second part, I tried to find a equation to describe the process similar to fibonacci rabbits which I remembered from [[rosalind.info]]. I did not succeed. Since fish that are on the same reproductive cycle behave the same, we can just keep track of one and keep a count of how many there are.

* DONE Day 07
  Main idea is to sort the positions and iterate from one end to the other. If we are at a position Pc and PL, PR are positions left and right of Pc. The fuel cost for Pc is sum(PR)-size(PR)*Pc + size(PL)*Pc-sum(PL).
  I need to keep track of these sections properly.
  Since in the above equation we have the only variable quantity as (size(PL) - size(PR))*Pc, this part has maximum and minimum only at the boundaries. Thus we only need to consider the positions given. It will never be inbetween.
  The total sum(PR)+sum(PL)+sum(Current) must be constant; and size(PL)+size(PR)+1 must be the total size. These invariants should help manage all the variables.
  <2021-12-25 Sat> After struggling with this a while, I just went with a brute force solution. It is O(n^2) rather that O(nlogn) but the N is small enough so runtime does not really matter. But I do feel defeated.
  For the second part the cost function is quadratic w.r.t the distance. Hence the optimal position is not at the ends but in between the nodes. So I am iterating every point in range.
