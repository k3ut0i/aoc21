* TODO Day 01
  - Note taken on [2021-12-19 Sun 16:50] \\
    I am getting a repeat count for the second part of the answer.
    There is some problem with boundary condition. Fix this.
  I just need to iterate through the list once. So a simple linked list would suffice.
  - Since creating the list would give me the reverse of it, I need to count the decreasing depth.
    + Hmm, it would seem that ~std::list~ allows iterating from the back too(doubly linked list).
      I will just iterate from the back for simplicity.

* DONE Day 02
  In the previous problem, when trying to read numbers sequentially, I did ~filestream >> num~. I want to do this for a complicated data structure ~filestream >> data~. What should I define for this to work?
  <2021-12-19 Sun> Got it to work. There is a bug. If the eof does not occur directly after the data, i.e., there is an extra newline, [[file:src/day02.cc::std::list<struct command> read_commands(std::string filename) {][~read_commands~]], then the program crashes trying to parse this whitespace into a ~struct command~. Now how do I tell if all that is left in the stream is whitespace?
  <2021-12-20 Mon> Solved the whitespace before eof problem by just ~peek~ and ~get~ while the ~peek~ satisfies ~isspace~.

* DONE Day 03
  I have solved a similar problem before on Average of several DNA sequences. 
  I did not use any ~lambdas~. There are instances to use ~map~ on ~std::list~, but I seem to be just using ~for~ loops.
  <2021-12-20 Mon> Something is segfaulting in part2; probably some dereferencing a bitset.
  <2021-12-21 Tue> I was deleting nodes in a list while traversing. So when I deleted a node and then used it to get the next node, the result was a segfault.

* DONE Day 04
  Finished coding the logic. Cards are not being marked at all. Needs debugging.
  - The set of marked indices is not being updated. What am I missing?
    + figured it out. I should have passed ranged over state using ~auto &~. By just using ~auto~ I was not propagating changes back to state.
  - Similar to previous day, I seem to be struggling with deleting nodes of a list while traversing it.
  I would not have struggled this much if I just tried to simulate the whole process of find the last card in my head.
  
* DONE Day 05
  Finding the density of lines.
  - I am loving the ~operator>>~ to parse the incoming data. Feels quite like Haskell ~ReadS~ parsing.
  - Took a couple of tries to get the line stepping logic to get right.

* DONE Day 06
  I am having trouble using header files and libraries.
  - linker is complaining of unable to resolve the function reference. Is there a problem with function name or template instantiation?
    + I almost stumbled upon the answer. Since a templated function compiled into instantiated versions where it is required, we need to know it's uses before compiling the object file. Thus we can only use it if the definition is within the translation unit of it's use. We can do this if the function is defined within the header file. We cannot enumerate all instances of template function; thus every instantiation might be compiled again anyway. So this is not much of a disadvantage to the compilaiton process.
  For the second part, I tried to find a equation to describe the process similar to fibonacci rabbits which I remembered from [[rosalind.info]]. I did not succeed. Since fish that are on the same reproductive cycle behave the same, we can just keep track of one and keep a count of how many there are.

* DONE Day 07
  Main idea is to sort the positions and iterate from one end to the other. If we are at a position Pc and PL, PR are positions left and right of Pc. The fuel cost for Pc is sum(PR)-size(PR)*Pc + size(PL)*Pc-sum(PL).
  I need to keep track of these sections properly.
  Since in the above equation we have the only variable quantity as (size(PL) - size(PR))*Pc, this part has maximum and minimum only at the boundaries. Thus we only need to consider the positions given. It will never be inbetween.
  The total sum(PR)+sum(PL)+sum(Current) must be constant; and size(PL)+size(PR)+1 must be the total size. These invariants should help manage all the variables.
  <2021-12-25 Sat> After struggling with this a while, I just went with a brute force solution. It is O(n^2) rather that O(nlogn) but the N is small enough so runtime does not really matter. But I do feel defeated.
  For the second part the cost function is quadratic w.r.t the distance. Hence the optimal position is not at the ends but in between the nodes. So I am iterating every point in range.

* TODO Day 08
  After determining unique numbers, we have to check all inputs and determine which configuration is valid.
  It should even be possible to brute force this. Have to check 1 million cases approximately; but it could be done. Maybe I will try it after optimal solution; else I would not be motivated to do a better one.
  <2021-12-26 Sun> Test case for finding the correct permutation worked. I need to decode and add the numbers now.
  <2021-12-27 Mon> I just went with brute-force searching. It did not even take a couple of seconds even with debug flags set.
  #+begin_example
    real    0m0.281s
    user    0m0.277s
    sys     0m0.004s
  #+end_example
** TODO Optimal solution
   Must atleast try a optimal solution. I always try to skirt around implementing a backtracking search in imperative languages.

* DONE Day 09
  First part is simple enough. Iterate over every cell and check some property.
  Second part is something new. I need to start with a deep point and keep marking the basin untill all boundaries are reached. It is like finding connect components of a given graph
  - The neighbours closure is was very buggy.
  <2022-01-02 Sun> Finally debugged this. This is the same transitive closure problem that is disguised using depths that do not really matter. I generate a simple image to visualize the regions a bit too.
  #+NAME: basins-grayscale-colored
  [[./gen/day09_basins.pgm]]

* TODO Day 10
  I used a stack to track the open characters. If the closing char doesn't match the top open char on the stack then it is corrupt. If there are still open chars left in the stack after the input if over then it is incomplete. So we can get all requirements in one iteration of the input line.
  <2022-01-02 Sun> For some reason the second part is giving me an incorrect answer, despite the given example working perfectly.

* Day 11
  Since both test case and actual input have 10x10 grids, I will just hand code it into the answer rather than try to figure it out from the file.
  Simultaneous flashing was a bit tricky to get right. I again used a stack to keep track of neighbours who might flash. No wonder a stack is always suggested for depth first search problems. It makes the mental model very clear. 
